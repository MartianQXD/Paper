\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicotherwise{\textbf{otherwise}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algdef{SE}[CASE]{Otherwise}{EndOtherwise}[1]{\algorithmicotherwise\ #1}{\algorithmicend\ \algorithmicotherwise}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%
\algtext*{EndOtherwise}%
\usepackage{tabularx}
\usepackage{array}















\begin{document}
\title{Verifying Strong Ground Bisimilarity of Quantum Communication Protocols}
\author{First Author\inst{1} \and
Second Author\inst{2,3} \and
Third Author\inst{3}}

\authorrunning{}

\institute{University, Princeton NJ 08544, USA \and
Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
\email{lncs@springer.com}\\
\url{http://www.springer.com/gp/computer-science/lncs} \and
ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
\email{\{abc,lncs\}@uni-heidelberg.de}}

\maketitle

\begin{abstract}This paper gives a strong ground bisimulation verification algorithm for quantum programs. We further implement the algorithm that enable us to make experiments on existing quantum communication protocols. As a preparation of the experiments, we encode the quantum communication protocol into a quantum program. Then we check whether a quantum program is bisimilar with its specification. According to the results, we make some improvements on the quantum programs.

\keywords{Quantum programs  \and Verification \and Bisimualtion.}
\end{abstract}

\section{Introduction}

\section{Preliminaries}

\section{qCCS}

\section{Bisimulation Verification}
In this section, we give an algorithm to verify the strong ground bisimulation between two pLTSs and show its implementation.
\subsection{A Strong Ground Bisimilarity Checking Algorithm}
The algorithm is based on the work of \cite{TOCL2014}. The main function is \textbf{Bisim}$(t,u)$, its job is to initialize the start states pair $(t,u)$, visited states pair $W$ which is an empty set and then find the bisimulation basing on that initialization. The difference between it and the previous work in several aspects.

The algorithm keeps updating two sets $W$ for visited states pairs and $N$ for non-bisimilar states pairs. The function \textbf{Match}$(t,u,W)$ invokes a depth-first traversal to match a pair of 
states $(t,u)$ with all their possible behaviors. The states pair is checked to be non-bisimilar if one of their transitions are not matched or their quantum variables, so do the quantum registers, are not matched. Then the algorithm adds the current states pair into $N$. 

An auxiliary function \textbf{Act}$(t,u)$ is called in \textbf{Match} to discover the next action that both two states can behave. If both two states have no more action it returns an empty set. Furthermore, if there is only one of them has no more action it will lead to a non-bisimilarity. It makes the algorithm more efficient as it terminates at an early time point if those pLTSs are indeed not bisimilar. Next we prove why we can ensure that.
\begin{theorem}[Early termination]
If the algorithm reaches a leaf state of the tree-like pLTS while the state of the other pLTS is not leaf state, then these two pLTSs are not bisimilar.
\end{theorem}
\begin{proof}
We consider it on the aspect of the length of the traces. From the structure of the algorithm, each time \textbf{MatchAction} is called \textbf{Act} will be called before it. So the we can ensure that two states have the same action to behave. There exists the trace that
\[T = \langle t_0,\rho\rangle\xrightarrow{\gamma_0}...\xrightarrow{\gamma_i}\langle t_i,\rho\rangle\text{ and }U = \langle u_0,\sigma\rangle\xrightarrow{\gamma_0}...\xrightarrow{\gamma_i}\langle u_i,\sigma\rangle.\]
Let $|T|=|U|=n$, if one of these states $u_i$ is not leaf state, then there has a longer trace $|U'|=n+1$. As there is no loop contained, the trace $|T'|=n+1$ does not exist, so we can not find a trace has the same length as the other one. According to the definition of the open bisimulation, these two pLTS should not satisfy the relation.
\end{proof}

The other set $W$ is update in function \textbf{MatchAction}$(\gamma,t,u,W)$. It discovers next states pairs according to the action $\gamma$ and recursively invokes the function \textbf{Match} when there is a pair of states or \textbf{MatchDistribution} when there is a pair of distributions of states. The current states pair is added to $W$ when it invokes new function.

The \textbf{MatchDistribution}$(\Delta,\Theta,\textit{R})$ is an extra step if we match a pair of distributions of states instead of a single pair of states. It returns a boolean value indicating if the distributions are bisimilar. It continues invoking \textbf{Match} to match next pair of states from the pair of states distributions. After checking the bisimilarity of their states, the function generates an equivalence relation of the states from the distribution those who are not contained in the non-bisimilar states set $N$. Another auxiliary set \textbf{Check}$(\Delta,\Theta,\textit{R})$ is used for checking the lifting condition of the bisimulation relation. Besides the lifting condition, we check the disjunction of the returning boolean value from \textbf{Match} functions. The function return such result basing on the following theorem.

\begin{theorem}[Bisimulation of distributions]

Let $\textit{R}\subseteq Dist(Con)\times Dist(Con)$ be the (strong) open bisimulation relation between two distributions, then for any $\mu,\nu\in Dist(Con),\ \mu\textit{R}\nu$ can imply that:
\begin{item}
\item[(1)] The relation satisfies the lifting condition, that is $\mu=\sum_{i\in I}p_i\textit{C}_i$, for each $i\in I,\ \textit{C}_i\textit{R}\textit{D}_i$ for some $\textit{D}_i$, and $\nu=\sum_{i\in I}p_i\textit{D}_i$.
\item[(2)] The set $I$ is not an empty set, s.t. $\exists C,D\in Con, \mu(C)>0\wedge\nu(D)>0$.
\end{item}
\end{theorem} 
\begin{proof}
From the definition of the lift operation, the condition must be satisfied. And we need to filter the case that two distributions have no behaviour in common, so there need at least a pair of states is bisimilar.
\end{proof}
The correctness of the algorithm is presented in the theorem below.
\begin{theorem}[Termination]
For two states $t$ and $u$, the algorithm always terminate.
\end{theorem} 
\begin{proof}
So far there is no while-loop in the qCCS, that brings convenience to the proof of termination. Starting at the initial pair of states, the next action to do will be detected in the function \textbf{Match}. Then it invokes function \textbf{MatchAction} to find the next new pair of states and recursively call function \textbf{Match} to check them. Each time function \textbf{MatchAction} calls function \textbf{Match} it adds the current states pair into $W$ at the same time. If we reach the leaf nodes, there is no more action, we only compare the quantum variables used and the state of quantum registers. After that, the function terminates, so do the calls to the other functions. Moreover, if there still exists actions to do in one of the pLTS while another one does not, that means they are not strong bisimilar and then the whole algorithm terminates. 
\end{proof}
\begin{algorithm}[h]
\caption{Bisim(t,u)}
\label{alg_bisim}
\begin{algorithmic}[1]
\Require A pair of initial states for matching $t$,$u$.
\Ensure A boolean value $\theta$ showing if two pLTSs are bisimilar and a set of non-bisimilar state pairs $N$.
\Function{\textbf{Bisim}}{$t,u$}
\State \textbf{return} \textbf{Match}(\textit{t,u,W})
\EndFunction
\State
\Function{\textbf{Match}}{$t,u,W$}\Comment{$t=\langle t,\rho\rangle\ and\ u=\langle u,\sigma\rangle$}
\If{$t,u\in W$}
    \State $\theta:=\texttt{tt}$
\Else
    \For{$\gamma\in \texttt{Act}(t,u)$}
        \State ($\theta_{\gamma} ,N_{\gamma}$):=\textbf{MatchAction}(\textit{$\gamma$,t,u,W})
    \EndFor
    \State $\theta$:=$\bigwedge_\gamma\theta_\gamma\wedge qv(t)=qv(u)\wedge tr_{\overline{qv(t)}}(\rho)=tr_{\overline{qv(t)}}(\sigma)$
    \State $N=\bigcup_{\gamma}N_\gamma$
    \If{$\theta=\texttt{ff}$} $N$:=$N\cup \{(t,u)\}$ \EndIf
\EndIf
\State \textbf{return} ($\theta,N$) 
\EndFunction
\State
\Function{\textbf{MatchAction}}{$\gamma,t,u,W$}
\Switch{$\gamma$}
\Case{$c!$}
\For{$t\xrightarrow{c!e_i}t_i \text{ and } u\xrightarrow{c!e'_j}u_j$}
    \State $(\theta_{ij},N_{ij}):=\textbf{Match}(t_i,u_j,W\cup \{(t,u)\}$
\EndFor
\State \textbf{return} $(\bigwedge_{i}(\bigvee_j(\theta_{ij}\wedge e_i=e'_j))\wedge\bigwedge_{j}(\bigvee_i(\theta_{ij}\wedge e_i=e'_j)),\bigcup_{ij}N_{ij})$
\EndCase
\Case{$\tau$}
\For{$t\xrightarrow{\tau}\Delta_i \text{ and } u\xrightarrow{\tau}\Theta_j$}
    \State $(\theta_{ij},N_{ij}):=\textbf{MatchDistribution}(\Delta_i,\Theta_j,W\cup \{(t,u)\}$
\EndFor
\State \textbf{return} $(\bigwedge_{i}(\bigvee_j\theta_{ij})\wedge\bigwedge_{j}(\bigvee_i\theta_{ij}),\bigcup_{ij}N_{ij})$
\EndCase
\Otherwise{}
\For{$t\xrightarrow{\gamma}t_i \text{ and } u\xrightarrow{\gamma}u_j$}
    \State $(\theta_{ij},N_{ij}):=\textbf{Match}(t_i,u_j,W\cup \{(t,u)\}$
\EndFor
\State \textbf{return} $(\bigwedge_{i}(\bigvee_j\theta_{ij})\wedge\bigwedge_{j}(\bigvee_i\theta_{ij}),\bigcup_{ij}N_{ij})$
\EndOtherwise
\EndSwitch
\EndFunction
\State
\Function{\textbf{MatchDistribution}}{$\Delta,\Theta,W$}
\For{$t_i\in \lceil\Delta\rceil\text{ and }u_j\in \lceil\Theta\rceil$}
    \State $(\theta_{ij},N_{ij}):=\textbf{Match}(t_i,u_j,W)$
\EndFor
\State $\textit{R}$:=$\{(t_i,u_j)|(t_i,u_j)\notin \bigcup_{ij}N_{ij}\}*$
\State \textbf{return} ($\textbf{Check}(\textit{$\Delta$,$\Theta$,$R$})\wedge\bigvee_{ij}\theta_{ij},\bigcup_{ij}N_{ij}$)
\EndFunction
% \State
% \Function{\textbf{Check}}{$\Delta,\Theta,\textit{R}$}
% \EndFunction
\end{algorithmic}
\end{algorithm}
\subsection{Implementation}
Our tool is implemented in Python 3.7. Its workflow is illustrated in Fig.~\ref{fig:arch}. The input is a quantum program and its specification, both of them are described in qCCS. Execution of the tool yields a terminal output showing the details of the whole process, including the pLTS generation and the checking algorithm, and the result of the checking by a table mapping each pair of pLTS states to its most general boolean. The tool invokes Z3 solver to verify the most general boolean of the initial state pair. A counterexample will be given if the boolean can be unsatisfied.
\subsubsection{pLTS Generation}
The tool inputs programs codes containing three parts,a description of process behaviors, an initialization of their variables and a set of user-defined quantum gates. Process behaviors are described in qCCS semantics. Processes are separated by semicolons. Quantum gates can be defined through a set of kraus operators, they are also separated by semicolons. The intermediate output of the module is the pLTS which will be used as the input of bisimilarity checking module.
\subsubsection{Bisimulation Checking}
We implement the previously defined ground bisimlarity checking algorithm to verify the generated pLTSs. The input needs two pLTSs, one for protocol description and another for specification description. They are processed by the pLTS generation module. We start at the initial states of these two pLTSs. The result of the module is also the final result of the tool presenting whether these two pLTSs are bisimilar, always with a set preserving non-bisimilar state pairs.
\begin{figure}
\centering
\includegraphics[width=\textwidth]{images/architecture.eps}
\caption{Verification workflow.}
\label{fig:arch}
\end{figure}
\section{Case Studies and Experiments}
We provide several classical quantum communication protocols described in qCCS as the use cases for our experiment.
\subsection{Examples: Quantum Communication Protocols}
\subsubsection{Super-dense Coding Protocol} There are two roles $Alice$ and $Bob$. To simplify the experiment, we only consider the smallest case of the protocol, sending only one qubit. So in this example, there is totally one entanglement on two qubits. Besides the Clifford operators, we use a quantum operation $Set^{\Psi}$ to present the generation of Bell state instead of the combination of the quantum gates. The operation elements of $Set^{\Psi}$ is $\{|\beta_{00}\rangle\langle00|,|\beta_{00}\rangle\langle01|,|\beta_{00}\rangle\langle10|,|\beta_{00}\rangle\langle11|\}$. The measurement is according to the computational basis $|00\rangle,|01\rangle,|10\rangle,|11\rangle$. The specification of the super-dense protocol is defined as $Bob$ sets the 2-qubit variable to the value according to the classical value he received from $Alice$.
\subsubsection{Quantum Teleportation Protocol} In this example, there are still two roles. The operators we used here is similar with the last example containing Clifford operators, $Set^{\Psi}$ and the measurement according to the computational basis. However, we need one more entanglement and one more qubit if we just consider the smallest case. As there are entanglements between these qubits, the measurement on just a part of them may also affect the rest qubits. We considers the final result of this protocol, that is the third one, $Bob's$ qubit, becomes the same value of the first qubit. So the specification of that can be presented by applying a \textit{SWAP} operation between the first and the third qubit.
\subsubsection{BB84 Quantum Key Distribution Protocol}
\subsubsection{BB84 Protocol with an Eavesdropper} This example is an extension of the BB84 example, supposing there is an eavesdropper attending into the communication. 
\subsection{Experiment Results}
\begin{table}[h]
    \centering
\begin{tabular}{@{}m{0pt}@{}
                >{\centering\arraybackslash}m{4cm}
                |>{\centering\arraybackslash}m{2.5cm}
                |>{\centering\arraybackslash}m{2cm}
                |>{\centering\arraybackslash}m{2.5cm}}
\hline
\rule{0pt}{5mm}&\textbf{Program} & \textbf{Bisimilarity} & \textbf{Size of $N$} & \textbf{Runtime}(s) \\
\hline
\hline
\rule{0pt}{5mm}&super-dense coding & No & - & 2.6 \\
\hline
\rule{0pt}{5mm}&super-dense(modified) & Yes & 0 & 2.5 \\
\hline
\rule{0pt}{5mm}&Teleportation & Yes & 0 & 2.7 \\
\hline
\rule{0pt}{5mm}&BB84 & Yes & 304 & 4.7 \\
\hline
\rule{0pt}{5mm}&BB84(with eavesdropper) & No & - & 74.6 \\
\hline
\rule{0pt}{10mm}&BB84(with eavesdropper \& modified) & Yes & 17272 & 1834 \\
\hline
\end{tabular}
\end{table}

\section{Conclusion and Future Works}


% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{8}
\bibitem{TOCL2014}
Feng, Y., Deng, Y., Ying, M.: Symbolic Bisimulation for Quantum Processes. ACM Trans. Comput. Log. \textbf{15}(2), 14:1--14:32 (2014)


\bibitem{ref_article1}
Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

\bibitem{ref_lncs1}
Author, F., Author, S.: Title of a proceedings paper. In: Editor,
F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
Springer, Heidelberg (2016). \doi{10.10007/1234567890}

\bibitem{ref_book1}
Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
Location (1999)

\bibitem{ref_proc1}
Author, A.-B.: Contribution title. In: 9th International Proceedings
on Proceedings, pp. 1--2. Publisher, Location (2010)

\bibitem{ref_url1}
LNCS Homepage, \url{http://www.springer.com/lncs}. Last accessed 4
Oct 2017
\end{thebibliography}
\end{document}
